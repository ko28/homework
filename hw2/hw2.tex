\documentclass[11pt]{scrartcl}
\usepackage[sexy]{../evan}
\usepackage{cmbright}
\usepackage{cancel}
\usepackage[T1]{fontenc}
%\usepackage{enumerate}
\usepackage[shortlabels]{enumitem}
\usepackage[utf8]{inputenc}
\usepackage[margin=1in]{geometry}
%\usepackage[pdfborder={0 0 0},colorlinks=true,citecolor=red{}]{hyperref}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{setspace}
\usepackage{systeme}
\usepackage[vlined]{algorithm2e}
\usepackage{mathtools}
\SetStartEndCondition{ }{}{}%
\SetKwProg{Fn}{def}{\string:}{}
\SetKwFunction{Range}{range}%%
\SetKw{KwTo}{in}\SetKwFor{For}{for}{\string:}{}%
\SetKwIF{If}{ElseIf}{Else}{if}{:}{elif}{else:}{}%
\SetKwFor{While}{while}{:}{fintq}%
\newcommand{\forcond}{$i=0$ \KwTo $n$}
\SetKwFunction{FRecurs}{FnRecursive}%
\AlgoDontDisplayBlockMarkers\SetAlgoNoEnd\SetAlgoNoLine%


\title{CS 577: HW 2}
\author{Daniel Ko}
\date{Summer 2020}

\begin{document}
\maketitle

%problem 1
\section{
  Given the coordinates of each of the n events, find a viewable subset of
  maximum size, subject to the requirement that it should contain event n. Such a solution
  will be called optimal.
 }
\subsection{
	Write the iterative version of the algorithm to find the maximal size.
}


We will assume that $|\text{coordinate of n}| \leq n$ and are using zero based numbering for lists.

\begin{algorithm}
	\KwData{crd, a list of coordinates that corresponds to events.}
	\KwResult{Maximal amount of events we can view, given that we must view the last event.}
	\Fn{optimal(crd)}{
		\#dp holds the maximum amount of events you can view given you visit crd[i]\\
		dp $\leftarrow$ a list of 0's with the same length of crd\\
		dp[n-1] = 1 \\
		\For{\text{int i = length of event - 2; i $\geq$ 0; i--}}{
			possibleEvents $\leftarrow$ a empty list\\
			\For{int j = length of event - 1; i < j; j--}{
				\If{abs(crd[j] - crd[i]) $\leq$ j - i \textbf{and} i + 1 - abs(crd[i]) $\geq$ 0}{
					add crd[j] to possibleEvents
				}
			}
			\If{possibleEvents is not empty} {
				dp[i] = 1 + max element of possibleEvents
			}
		}
		\Return max element of dp
	}
\end{algorithm}



\subsection{
	Show the algorithm for tracing the events selected.
}


\KwData{dp, the list used for memoization\\
	\qquad \quad \enspace \ crd, a list of coordinates that corresponds to events \\
	\qquad \quad \enspace \ max, the maximal amount of events we can view }
\KwResult{List coordiantes of events to view.}
\Fn{events(dp, crd, max)}{
	\-\\ view $\leftarrow$ a empty list\\
	\For{each num in dp}{
		\-\\ find the right most max and add its index to view\\
		decrement max
	}
	\Return{view}
}\-\\

%\subsubsection{Partial correctness}
%\begin{proof}
%	Suppose fraudMajority halts. 
%\end{proof}
%\subsubsection{Termination}


\subsection{
	Give a brief argument of correctness.
}

\[
	\text{MaxEvent}(i)=
	\begin{cases}
		1 & \textbf{when } i = n - 1                                                                                   \\
		1 + \text{max}(\text{MaxEvent}[j_1], \text{MaxEvent}[j_2], \cdots )
		  & \textbf{if } \exists j > i \text{ s.t.} \mid \text{MaxEvent}[i]-\text{MaxEvent}[j] \mid \leq i - j \\
		  & \text{and } i + 1 - \mid \text{MaxEvent}[i] \mid  \geq 0                                              \\
		0 & \textbf{otherwise}
	\end{cases}
\]

Note that MaxEvent$[n-1]$ corresponds to the $n$th event because of our zero based numbering for lists. We compute
the recurrence relation descending, i.e. from $i = n-1$ to $i=0$.
\begin{theorem*}
	The recurrence relation, MaxEvent$(i)$ is most amount of events you can visit given that the first event you visit is at $i$ 
	and you end on $n$th event.
	\begin{proof}
		We show by strong backwards induction that our algorithm is correct. Let $P(i)$ be the predicate,
		"MaxEvent correctly computes the most amount of events you can visit given that the first event you visit is at $i$ 
		and you end on $n$th event".
		We define $i\in \mathbb{N}$. \\
		\textbf{Base Case:} When $i = n - 1$, MaxEvent returns 1 which is the correct output because if you start 
		at the $n$th event, the last event, you can only visit one event. Hence, $P(n-1)$ holds.\\
		\textbf{Inductive step:} Suppose $P(\alpha)$ holds for all $\alpha \leq n - 1$. We show that $P(\alpha-1)$ holds.
		Our recurrence relation looks for all $j > i = \alpha-1$ such that if you start at event $i$, you can visit event $j$.
		This part is given by, $$\exists j > i \text{ s.t. } \mid \text{MaxEvent}[i]-\text{MaxEvent}[j] \mid \leq i - j$$
		\par The second condition of the recurrence checks if it is possible to view event $i$, given you start at coordinate 0
		and can move 1 distance before the first event, i.e the second assumption given in the homework. This part is given by, 
		$$ i + 1 - \mid \text{MaxEvent}[i] \mid  \geq 0$$
		\par If both conditions hold, the most amount of events you can visit is the event at $i$, which is 1 event, plus
		the biggest MaxEvent from the $j$'s. By our strong backwards inductive hypothesis,
		MaxEvent$(j)$ returns the correct amount of events because we defined 
		$ j > i = \alpha - 1 \Leftrightarrow j \geq \alpha$. 

		
		\par By strong backwards induction, we have proven that $P(n)$ is true for all $n \in \mathbb{N}$.
		Therefore, MaxEvent is correct.
	\end{proof}
\end{theorem*}

\begin{theorem*}
The algorithm returns the maximal amount of events we can view, given that we must view the last event.

\begin{proof}
	Our algorithm evaluates the recurrence OPT(i) bottom-up by storing OPT(i) in DP[i].
	Note that since we evaluate DP[i] as i increases from 1 to n, all values for subproblems 
	referenced by the recurrence for OPT(i) will have already been computed. At the end, our 
	algorithm returns the maximum value in the DP array, which corresponds to the length of the 
	longest LIS that ends somewhere in the array, which in turn is an LIS of the overall array A.
\end{proof}

\end{theorem*}

\iffalse
	
	\par \textbf{Base Case:} When $k = 0$, fraudMajority halts and returns null which is the correct output
	because the collection is empty. Hence, $P(0)$ holds.
	\par \textbf{Inductive step:} Suppose $P(n)$ holds for all $n \leq k \in \mathbb{N}$. We show that $P(k+1)$ holds.
	\par We observe that fraudMajority recursively calls collections of sizes $\floor{(k+1)/2}$ and
	$(k+1) - \floor{(k+1)/2}$.
	Since $\floor{(k+1)/2} \leq k$ and $(k+1) - \floor{(k+1)/2} \leq k $, we know by our strong inductive hypothesis that these
	recursive calls must halt. Hence, fraudMajority halts with an input of $k+1$ cards.
	\par fraudMajority finds the majority card of its left and right side, of size $\floor{(k+1)/2}$ and
	$(k+1) - \floor{(k+1)/2}$ respectively. Since both of these collections are less than $k$, by our strong inductive hypothesis,
	these recursive calls must return the correct output, the majority card of that partition if it exists.
	Then our algorithm calculates the total number of the majority card on the right and left on our
	$k+1$ collection and returns the majority. If no majority exists, it returns null. Thus,
	fraudMajority returns the correct output for a collection of $k+1$ cards.

	\par By strong induction, we have proven that $P(n)$ is true for all $n \in \mathbb{N}$.
	Therefore, fraudMajority is correct.
\fi


\subsection{
	Analyze the running time.
}
We claim that the running time is $O(n^2)$.
\begin{proof}
	We have a nested for loop, which run at most $n$ times each.
	In the outer for loop, we search for the max element of an array
	which at most is size $n$. The rest of the computations in the outer for loop take constant time.
	Additionaly, after all the loops have been run, we search for the max element of dp which is
	size $n$. This leads to a total time complexity of $n(2n) + n = 2n^2 + n$.
	Thus, our total time complexity of our algorithm is $O(n^2)$
\end{proof}



%problem 2
\section{Please describe an algorithm that finds a number that is
  bigger than any of its neighbors.}
For brevity, we define a peak to be a number that is
bigger than any of its neighbors.
\subsection{
	Present your algorithm and explain the notations as necessary.
}

\iffalse
	\begin{algorithm}

		\KwData{arr, the $nxn$ matrix representing the grid of boxes}
		\KwResult{A number that is larger than its neighbors if it exists.}
		mid = floor(len(arr[0])/2) \\
		%row = len(arr)\\
		%col = len(arr[0])\\
		findLarge(arr, mid)\\
		\Fn{findLarge(arr, mid)}{
			max\_Col, max\_Col\_Index = maxColumn(arr, mid)\\
			\#Base Case: No local max number because we are checking the edges\\
			\If{mid $\leq$ 0 or mid $\geq$ len(arr[0]) - 1 or\\
				\ \ \ max\_Col\_Index $\leq$ 0 or max\_Col\_Index $\geq$ len(arr[0]) - 1 }{
				\Return null\\
			}\-\\
			\#Case 1: max\_Col is a local max, left and right are smaller\\
			\If{max\_Col > arr[max\_Col\_Index][mid - 1] and \\ \ \ \ max\_Col > arr[max\_Col\_Index][mid + 1]}{
				\Return max\_Col\\
			}\-\\
			\#Case 2: The number right of max\_Col is bigger, recursively call the right side\\
			\If{arr[max\_Col\_Index][mid + 1] > max\_Col}{
				\Return findLarge(arr, mid + floor(mid / 2))\\
			}\-\\
			\#Case 3: The number left of max\_Col is bigger, recursively call the left side\\
			\Return findLarge(arr, mid - floor(mid / 2))
		}

	\end{algorithm}
\fi


\begin{algorithm}
	\KwData{arr, the $nxn$ matrix representing the grid of boxes.}
	\KwResult{A peak.}
	\Fn{findLarge(arr)}{
		max $\leftarrow$ max element of boundary elements, middle row, and middle column\\
		\# Comparison is vacuously true for the neighbors that do not exist \\
		\If{max $>$ max's neighbors}{
			\Return max
		}
		%\If{size of arr $\leq 1x1$}{
		%	\Return null
		%}
		\# New submatrix does not contain the rows/columns used to find max\\
		recursive\_arr $\leftarrow$ the submatrix of the quadrant containing the largest neighbor \\
		\Return findLarge(recursive\_arr)
	}
\end{algorithm}

\subsection{
	Prove the correctness of your algorithm in finding the right box that has a number
	that is larger than all its neighbors.
}
\begin{proof}
	We show by strong induction that our algorithm is correct. Let $P(n)$ be the predicate,
	"findLarge halts and returns a peak in a $nxn$ matrix".
	We define $n \in \mathbb{N^{+}}$.
	\par \textbf{Base Case:} When $n = 1$, findLarge halts the only element in the matrix, which by definition
	is larger than its neighbors, a peak. Hence, $P(1)$ holds.
	\begin{theorem*}
		A peak exists in any given matrix where its elements are unique integers.
		\begin{proof}
			Let the set
			containing all the unique integers in the matrix be $S = \{a_1, \cdots, a_\alpha\}$.
			Take set $S' = \{b_1, b_2, \cdots\}$ to be the upper bound of $S$,
			where the upper bound is defined as $ \forall a_i \in S \ \ \forall b_j \in S', a_i \leq b_j$.
			Using the well ordering principle, there must exist as smallest element $b \in S'$.
			By definition, this must be the greatest element $a \in S$.
			Hence, there exist a largest integer in a finite set of unique integers.
			By definition, this largest integer is a peak.
		\end{proof}
	\end{theorem*}
	\begin{corollary*}
		There exists a peak in the submatrix of the quadrant containing the largest neighbor.
		\begin{proof}
			By previous theorem, there must exist a peak in the submatrix of the quadrant containing the largest neighbor
			because any subset of the original matrix containing unique elements, will have unique elements. Consider the
			special case where the peak is on the edge of the new submatrix. Let $\alpha$ be the largest neighbor in the original
			matrix and $\gamma$ be the max and peak on the edge. We know that $\gamma > \alpha$ because when we fix a max,
			by definition it is the
			greatest integer in the boundary elements, middle row, and middle column, which includes
			$\alpha$. This directly implies that $\gamma$
			is greater than all its neighbors within the original matrix because of the fact that $\alpha$ was the
			greatest integer of the values that directly border the submatrix.
		\end{proof}
	\end{corollary*}
	\par \textbf{Inductive step:} Suppose $P(n)$ holds for all $n \leq k \in \mathbb{N}^{+}$. We show that $P(k+1)$ holds.

	\par We observe that findLarge recursively calls with an matrix of size
	$\floor{(k-1) / 2} x \floor{(k-1) / 2}$.
	Since $\floor{(k-1) / 2} \leq k$, we know by our strong inductive hypothesis that this
	recursive call must halt. Hence, findLarge halts with a matrix of size $(k+1)x(k+1)$.

	\par If a peak does not exist in the boundary elements, middle row, and middle column, findLarge
	recursively calls the submatrix with the biggest neighbor. By the corollary above, there
	exist a peak in this submatrix. Since the size of the submatrix is $\floor{(k-1) / 2} x \floor{(k-1) / 2}$,
	and $\floor{(k-1) / 2} < k$, by our strong inductive hypothesis this recursive call returns a valid peak.

	\par By strong induction, we have proven that $P(n)$ is true for all $n \in \mathbb{N^{+}}$.
	Therefore, findLarge is correct.
\end{proof}

\subsection{
	Analyze the number of boxes that one need to open using your algorithm.
}
We claim that $T(n^2) = T((n/2)^2) + \Theta(6(n/2))$ which is $\Theta(n)$.
\begin{proof}
	Suppose we have a size $nxn$ matrix. Each recursive call will have a input size being one quarter
	of original matrix, which accounts for $T((n/2)^2)$. Additionally, when searching for the max element,
	we must search the boundary elements, middle row, and middle column, which would require, 6 times half the new input size
	i.e. $\Theta(6(n/2))$.
	The rest of the computations take constant time. Let $m = n^2$
	\begin{align*}
		T(n^2) & = T((n/2)^2) + \Theta(6(n/2)) \\
		T(m)   & = T(m/4) + \Theta(3\sqrt{m})
	\end{align*}
	Using the master theorem, it is clear that we get values of $a = 1, b = 4, d = \frac12$ for this particular
	recurrence which results in a complexity of $\Theta(\sqrt{m}) = \Theta(n)$.
\end{proof}
\iffalse
	Suppose we have a $nxn$ matrix.
	A call to our algorithm will result in single recursive call
	with its input sized being halfed. Additionally, for each
	recursive call, we must search the boundary elements, middle row, and middle column,
	which would require, 6 times half the input size time.
	\begin{align*}
		T(n^2) & = T(\frac{n}{2}x\frac{n}{2}) + \Theta(6(\frac{n}{2})) \\
		T(n)   & = T(\frac{n}{4}) + \Theta(3\sqrt{n})
	\end{align*}
\fi

\end{document}

